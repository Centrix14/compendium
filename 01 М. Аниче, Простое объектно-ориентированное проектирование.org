#+title: М. Аниче, Простое объектно-ориентированное проектирование
#+author: Centrix
#+startup: show4levels
* Аннотация
* Конспект
** Предупреждение
Нижеследующий конспект — не конспект в полном смысле этого слова. Очень часто авторская мысль здесь дополняется мыслями читателя.

** Глава 1. Управление сложностью
*** 1.1. Объектно-ориентированное проектирование и испытание временем
Все системы постоянно усложняются, это нормально. Самое важное в этом процессе — стремиться к /высокой сопровождаемости/ системы. Сохранение простоты, следование практикам чистого кода и т. п. — всё это не конечные цели, а только инструменты для достижения высокой сопровождаемости.

*** 1.2. Проектирование простых объектно-ориентированных систем
Что же такое сопровождаемость, а точнее, степень сопровождаемости?

Степень сопровождаемости — это величина усилий, которые нам необходимо приложить, чтобы:
1) изменить бизнес-правило,
2) добавить новые возможности,
3) исправить ошибку
4) и т. д.

Проект, у которого высокая степень сопровождаемости — это простой проект. Простота его состоит не в размере (проект может быть очень большим), а в том, насколько легко разобраться в отдельном компоненте, насколько легко внести изменение и проверить, что оно ничего не нарушает.

#+begin_comment
Понимание простоты, как сопровождаемости, будет использоваться далее во всей книге.
#+end_comment

Автор выделяет 6 принципов сохранения простоты (т. е. поддержания сопровождаемости):
1) простота кода,
2) согласованность объектов,
3) грамотность управления зависимостями,
4) высокое качество абстракций,
5) правильность работы с внешней инфраструктурой,
6) продуманная модульность.

Далее в главе даётся краткая характеристика каждого принципа. Детальному раскрытию принципов посвящены главы 2-7.

**** 1.2.1. Простой код
Первым, и самым явным, элементом простого проекта является простой код. Простота кода состоит, в основном, в его физической простоте — грамотном именовании, краткости, выразительности, 

**** 1.2.2. Согласованные объекты
Разработчик — это, в каком-то смысле, бог или творец. И опыт показывает, что мастерство бога — не всемогущество, а очень грамотное и тщательное самоограничение.

Ключ к созданию грамотных самоограничений — это согласованность объектов. Объекты не должны позволять делать с собой всё, что угодно. Они должны находиться лишь в определённом допустимом множестве состояний, выйти за которые несознательно нельзя. Если кто-то пытается ввести объект в состояние, в котором он не может существовать, этого кого-то нужно предупредить, а действие заблокировать.

#+begin_comment
Аниче приводит здесь пример с корзиной. Он говорит, что корзина должна управлять своим состоянием и не позволять, например, удалять из себя несуществующие товары. Это грамотная мысль.

Мне кажется, её можно развить: корзина не должна сама по себе управлять своим состоянием. Корзина — это хранилище, только хранилище и ничего более. А вот правила управления корзиной — это уже иная сущность. Управление корзиной стоит поручить отдельному классу — менеджеру корзины.

При таком подходе в проекте параллельно и непротиворечиво могут существовать несколько различных менеджеров корзины, которые реализуют различные правила.
#+end_comment

**** 1.2.3. Качественное управление зависимостями
В объекто-ориентированной системы классы будут неизбежно связываться друг с другом. Важно держать эти связи под контролем, в определённых условиями границах. Неграмотные зависимости могут порождать множество проблем: изменение одного класса ведёт к изменению другого, ошибка в одном месте порождает каскадный обвал во всей системе.

Поэтому классы (как и любые единицы проекта вообще) должны знать друг о друге как можно меньше.

**** 1.2.4. Хорошие абстракции
Абстракции необходимо проектировать с учётом дальнейшего расширения. Расширение должно быть стандартной, простой процедурой, выполнение которой никак не затрагивает существующий код.

**** 1.2.5. Правильная работа с внешними зависимостями и инфраструктурой
Инфраструктура — это всё, что находится за пределами нашей системы и требуется для её работы. Не смотря на то, что связь между системой и инфраструктурой очень высока, инфраструктура может со временем изменяться; на систему эти изменения влиять не должны.

Чтобы добиться гибкости в работе с инфраструктурой нужно отделять доменный слой от инфраструктурного слоя.

#+begin_comment
По-сути это требование напрямую исходит из качественного управления зависимостями. Единственное отличие между этими принципами состоит в том, что принцип разделения домена и архитектуры фокусируется на внешнем взаимодействии системы, на сохранении системы, как целого, в системе высшего порядка.
#+end_comment

**** 1.2.6. Продуманная модульность
Между принципом № 3 (управление зависимостями) и принципом №5 (разделение домена и инфраструктуры) стоит принцип № 6: принцип продуманной модульности.

Простую систему недостаточно разделить на классы, недостаточно отделить доменную логику от инфраструктурной. Необходимо так же грамотно разделять систему на внутренне связные целые — модули. Модули должны представлять собой чёрные ящики, которые знают друг о друге не дальше интерфейса.

Решение задачи приложения в таком случае сводится к правильной /координации/ модулей.

#+begin_comment
Акцент на слове «координация» важен потому, что модули должны быть совершенно независимы, их взаимодействие нужно координировать, организовать, как дирижёр помогает музыканту понять своё место в оркестре.
#+end_comment

*** 1.3. Простое проектирование как повседневная деятельность
Одна из важнейших идей автора — это повседневность, обыденность проектирования. Проектирование нужно рассматривать не как этап, который в развитии системы не повторяется, а как один из процессов жизнедеятельности системы. Пока система жива, она постоянно проектируется (а в большей степени — перепроектируется).

#+begin_comment
У этой мысли есть две неочевидные стороны, на которые автор не обращает внимания.

Во-первых, проектирование системы, если оно превращается в повседневную деятельность, должно быть достаточно простым, эффективным и быстрым. Оно должно быть так же просто и так же необходимо, как дыхание. Это означает, что проектирование нужно изучать, доводить его знание до такой степени, на которой некоторые действия будут выполняться автоматически. Это требует больших вложений, как когнитивных (разработчики должны быть хорошо обучены), так и организационных (должны существовать все условия для постоянного перепроектирования).

Во-вторых, идеальная (или простая) архитектура — это архитектура, которая стремится к идеалу (или простоте). То есть идеальность или простота архитектуры — это не статическая характеристика, не свойство, а закон развития архитектуры.
#+end_comment

Автор приводит следующие принципы простого, повседневного проектирования.
1. Уменьшение сложности системы (т. е. цель простого проектирования) сродни личной гигиене. Если человек для поддержания себя чистит зубы и моется, то систему нужно постоянно проектировать, нужно постоянно уменьшать её сложность.
2. Если сложность /сейчас/ неизбежна, то её нужно уменьшить /впоследствии/. Этот принцип вытекает из предыдущего: человек не всегда может почистить зубы, но он делает это, как только появляется такая возможность. Сложность нужно уменьшать тогда, когда путь к этому известен — обнаружен практикой или анализом предметной области.
3. Сокращение сложности — один из факторов экономической эффективности разработки. Системы, в которых сложность не сокращается, постепенно накапливают /технический долг/, т. е. массив нерешённых задач и проблем. Само существование этого массива и рост его приводит к дополнительным расходам — к процентам, которые причитаются к этому техническому /долгу/.
4. Качественный код порождает качественный код. Плохо спроектированная система будет вынуждать разработчиков принимать дальнейшие плохие решения. Это приводит к тому, что качество кода постоянно снижается, плохие решения порождают плохие решения. Качественный код служит обратным примером: он так же вынуждает разработчика принимать качественные решения, хотя сам он может этого и не замечать.
5. Сложность нужно обнаруживать, как можно раньше. (В оригинале этот пункт назван совершенно иначе, но я название даю по содержанию принципа.) В комментарии выше говорилось, что повседневное проектирование требует высокой квалификации разработчиков. Эта мысль раскрывается в данном принципе. Для обнаружения сложности на ранних стадиях реализации чего-либо (всей системы, отдельной функции) разработчики должны обладать большим опытом и знаниями.
6. Удержание сложности — долг разработчика. Прямая обязанность разработчика состоит в том, чтобы поддерживать ценность системы для организации. Система, неспособная удовлетворить нужды организации, бесполезна. Но в нужды организации входит не только автоматизация некоторых функций, но и разумная экономия. Поэтому разработчик должен поддерживать систему такой, чтобы обслуживание её не требовало сверхъестественных затрат.
7. Необходимо достигать «достаточно хороших» решений. Ранее говорилось, что проектирование — это постоянный, итеративный процесс. Опыт показывает, что найти лучшее решение с первого раза нельзя. Поэтому стоит принимать «достаточно хорошие» решения, т. е. такие решения, которые решают поставленную задачу и делают это «чуть выше среднего».

#+begin_comment
По этим принципам нужно заметить следующее.

Принципы 1 и 3 в самом общем смысле применимы не только к сложности.

Одна из трудностей, с которой сталкиваются разработчики больших систем, — это устаревание технологий, выходят новые версии языков программирования, библиотек, а систему нельзя переписать сразу. Иногда объём систем столь велик, что переписывание вообще экономически нецелесообразно.

Однако постепенное переписывание системы, переписывание, как повседневная задача, уже вполне возможно. Но такой подход требует грамотного проектирования системы, среды исполнения; кроме того, необходимо продуманное управление, которого обычно нет (а ведь именно его отсутствие и приводит к появлению огромных и не переписываемых систем).

Принцип 4, как многие общие принципы программирования (например, DRY и KISS) достаточно абстрактен. Ясное дело, что невозможно в /общем/ принципе предусмотреть все возможные /частные/ случаи. Но это не значит, что общий принцип вообще должен абстрагироваться от чего бы то ни было. Необходимо определить критерии качественного решения.
#+end_comment

*** 1.4. Краткое знакомство с архитектурой системы
#+begin_comment
Эту часть конспекта стоит расценивать не как конспект, а как интерпретацию. Реально законспектировать параграф 1.4 трудно, так как автор выражается весьма неконкретно, в его изложении почти нет системы. Я попытался эту систему внести.
#+end_comment

Далее в книге примером будет служить информационная система с веб-интерфейсом. В этом параграфе автор делает краткий экскурс в устройство ИС.

Архитектуру системы-примера можно рассмотреть с двух точек зрения:
1) точка зрения веб-технологий,
2) точка зрения логического строения системы.

С точки зрения веб-технологий система-пример представляет собой совокупность фронтенда, бэкенда и БД. Из этих компонентов автора больше всего интересует бэкенд.

С точки зрения логического строения, система-пример распадается на представление, контроллер и модель (MVC). Представлением служит фронтенд, контроллер и модель — части бэкенда. Автора больше всего интересует модель, ведь именно она сосредотачивает в себе все проблемы.

#+caption: Связь т. з. веб-технологий и логического строения
#+org_attr: :scale 1
[[file:img/01-1.4-arch.drawio.png]]

В состав модели входят следующие типичные классы:
- сущности — это /классы/ (т. е. речь о классах, а не сущностях логической модели БД), которые представляют классы объектов предметной области;
- сервисы — это классы, которые описывают сложные правила предметной области, взаимодействие сущностей;
- репозитории — это классы, ответственные за хранение данных (они взаимодействуют с БД);
- адаптеры — это классы, ответственные за взаимодействие с инфраструктурой.
#+begin_comment
Такой состав модели отражает её истинную, активную роль. Модель — это не просто код доступа к СУБД, это программное отражение объекта предметной области. Хранение, доставка и получение данных тоже входят в обязанности модели (для этого там есть репозитории и адаптеры), но сердце и суть модели в предметной области, т. е. в сущностях и сервисах.
#+end_comment

Во взаимодействии модели и контроллера большую роль играют:
- объекты передачи данных (ОПД, DTO) — это классы, которые отвечают за хранение и передачу данных /внутри бэкенда/ (это отличает ОПД от репозиториев, которые работают уже с БД);
- утилитарные классы.

#+caption: Соотношение классов и компонентов MVC
#+org_attr: :scale 1
[[file:img/01-1.4-class.drawio.png]]

Приведённая ранее архитектура достаточно общая и универсальная, не стоит рассматривать её как архитектуру конкретную, вроде предметно-ориентированной архитектуры (DDD) или архитектуры микросервисов.

*** 1.5. Пример проекта: PeopleGrow!
Теперь автор конкретно рассказывает о примере ИС, которая используется в книге. Эта ИС — приложение для отслеживания роста квалификации сотрудников PeopleGrow!. Ничего интересного в описании этой системы нет.

*** 1.6. Упражнения
№ 2 не рассматривается.

**** 1
Понимание термина «простое объектно-ориентированное проектирование» зависит от понимания слова «простое».

Простоту можно отождествить со скоростью, т. е. с тем, что времени и сил на проектирование отводится немного. Но такое понимание обманчиво, ибо исходная простота и скорость оборачивается сложностью и длительностью впоследствии.

Значит, простоту нужно понимать глубже. Простота — это согласованность и ясность логики, точность отображения предметной области. Этих трёх характеристик (а особенно точности) добиться быстро нельзя, они — предмет серьёзного проектирования. Но серьёзное проектирование будет действительно серьёзным тогда, когда оно будет постоянным, непрерывным.

Непрерывность проектирования приводит к тому, что оно становится обыденной задачей, начинает постепенно сливаться с разработкой, не лишаясь при этом своих особенностей. Так проектирование становится /простым/, т. е. вливается в жизнь. Простота проектирования подобна простоте дыхания. Дыхание — сложный процесс, но он происходит незаметно, хотя очень точно и верно. В этом состоит его простота. В этом простота и непрерывного, постоянного проектирования и перепроектирования.

**** 3
Сохранить простоту проекта возможно, но нужно понимать, что в результате непрерывного проектирования система перерождается, эволюционирует. Поэтому само понятие простоты так же изменяется. Простота — это не состояние и не свойство, это стремление.

Среди проблем, которые связаны с сохранением простоты, можно выделить:
- изменение связанных с системой компонентов: изменение API СУБД или внешних сервисов;
- рассогласование объектов: развитие системы — это прогресс в познании предметной области, чем точнее система отображает объекты реального мира, тем сложнее они оказываются, тем больше различий между ними; то, что было единым и согласованным становится множественным и несовместимым; возникает потребность в перепроектировании;
- разрастание кода и модульной системы: по мере усложнения системы в ней появляется всё больше модулей, методы становятся всё длиннее, первоначальная выразительность сменяется многословием; если не бороться с этими явлениями, то ситуация будет со временем только ухудшаться.

** Глава 2. Сокращение кода
Автор говорит о вреде /длинных/ единиц кода (методов, классов). При этом он невольно отождествляет /длину/ и /сложность/. Объединение этих понятий уместно в большинстве случаев, т. е. в случаях очевидных. В случаях неочевидных, редких такое отождествление приносит огромный вред.

В целом автор, конечно, прав. Однако упущение этой детали делает изложение поверхностным.

*** 2.1. Уменьшите единицы кода
Необходимость уменьшать код связана не со стремлением к лаконичности или красоте. Конечно, они играют имеет роль, но программирование является программированием потому, что решающую роль в нём играет практичность.

Каковы практические последствия удлинения единиц кода?

Во-первых, произвольное разрастание единиц кода может быть симптомом искажения логики предметной области. Чаще всего большие методы и классы смешивают в одной сущности сразу несколько самостоятельных объектов. Развитие таких единиц кода может только ухудшить ситуацию и сделать систему несовместимой с предметной областью.

Во-вторых, удлинение единиц кода снижает его тестируемость. Если причиной большой длины служит смешение различного, то полно и достоверно протестировать код становится затруднительным.

В-третьих, удлинение кода снижает его расширяемость. Самостоятельные единицы кода на то и самостоятельны, что их можно заменить другими при помощи точно определённой и ясной процедуры.

#+begin_comment
Автор, кроме прочего, указывает, что длинные методы и классы больше подвержены изменениям и ошибкам. Неизвестной остаётся, однако, причина этого. Она может быть в том, что такие единицы сложнее поддерживать. А может быть в том, что они просто /больше/. В чём истина непонятно.
#+end_comment

Все эти следствия могут значительно усложнять разработку, поэтому необходимо уменьшать единицы кода. Как именно это делать? Ответ на этот вопрос дан в следующих подразделах.

**** 2.1.1. Разбивайте сложные методы на закрытые
Длинные методы необходимо разбивать на более мелкие и, как правило, закрытые. Целью разбиения методов должно быть достижение /связности/.

Связность — это целостность, которая изменяется по собственному закону и остаётся неизменной в различных условиях применения.
#+begin_comment
Это определение отсутствует в книге. Автор определяет связность просто, как наличие единой ответственности. Это определение весьма скудно и мало даёт читателю, поэтому я дал своё.
#+end_comment

Это определение значит, что:
- связный метод — это целостный метод, все его части крепко связаны, а их разделение будет только вредить;
- связный метод изменяется, развивается по своим собственным, независимым законам;
- связный метод может действовать в несколько разных условиях, оставаясь при этом неизменным.

Второй пункт, пункт о законах изменения представляется наиболее важным.

Автор приводит следующие условия того, что метод стоит выделить из другого:
1) методу легко подобрать имя, это имя будет чётко и ясно определять суть метода;
2) метод выполняет небольшое, целостное действие, которое может использоваться в открытом методе;
3) метод не слишком сильно переплетён с параметрами открытого метода и состоянием объекта;
4) метод можно сделать статическим (важно, что его /можно/ сделать статическим, это не означает, что его /нужно/ сделать таким).

Эти условия помогают понять, нужно ли вынести часть одного метода в другой метод (обычно, закрытый). Но возможен случай, когда из метода выделяется не новый метод, а класс. Этот случай рассмотрен в следующем разделе.

**** 2.1.2. Переместите сложную часть кода в другой класс
В ряде случаев оказывается полезным выделить часть длинного метода в отдельный класс. Автор приводит следующие условия этого:
1) метод не зависит от данного класса;
2) метод зависит от других классов;
3) метод принадлежит самостоятельному объекту предметной области;
4) метод необходимо тестировать, как самостоятельную единицу.

#+begin_comment
Важно понимать, что пункты 1-2 имеют смысл только для объектных систем с передачей сообщений. В таких системах метод принадлежит классам и их экземплярам. Объектные системы в Java, C#, Python реализуют именно такой механизм.

Но кроме систем с передачей сообщений, существуют системы с мультиметодами. В таких системах метод представляет собой самостоятельную сущность, которая /связывается/ с классом, но не /принадлежит/ ему. Мультиметоды встречаются в CL, Elixir, Dylan.
#+end_comment

Однако есть случаи, когда разделение кода может быть вредным. Рассмотрим их.

**** 2.1.3. Когда не стоит разделять код на небольшие единицы
Не стоит разделять код на небольшие единицы тогда, когда эти единицы /целостны/, и как целое развиваются по своим законам. Более конкретно это означает, что:
- разделение единиц затруднительно — они слишком сильно переплетаются друг с другом;
- разделённые единицы невозможно будет заменить;
- разделяемые единицы невозможно протестировать независимо.

Кроме того, не стоит забывать о практичности. Код, разделённый слишком сильно, становится слишком трудным для поддержки, возникает проблема правильного связывания элементов.

Ситуацию, когда целостный класс разделён на множество мелких, Джон Оустерхаут называл /классянкой/.

Все перечисленные ранее правила стоит, очевидно, применять до рефакторинга. Хорошо представлять, как именно преобразуется код, возникнут ли какие-нибудь проблемы. В этом состоит содержание раздела 2.1.4., который не вынесен в этом конспекте в отдельный пункт.

Следующий раздел — 2.1.5. содержит пример разделения методов. Интереснейшая его особенность в том, что автор не пытается довести код до идеала. Он делает его лучше и останавливается тогда, когда необходимости в дальнейшем разделении практика не обозначает. В этом сказывается суть /простого ОО-проектирования/ — стремиться к идеалу не статически, а динамически, объединить перепроектирование и кодинг.

*** 2.2. Сделайте код читаемым и документируйте его
В целом этот раздел можно изложить очень кратко. Деление его на подразделы кажется излишним.

Код должен быть читаемым. Это не значит, что он должен читаться, как рассказ, подобное утверждение слишком сильно, оно не учитывает, что код должен быть /практичным/, а не /идеальным/. Тем не менее, код должен быть выразительным и точным. Одна из основ этого — ясность имён. Самый важный принцип именования таков: имена нужно постоянно искать. Если опыт показывает новое, ещё более точное имя, то его следует использовать. Если же ничего такого нет, имя можно оставить. Одним словом, хорошее имя нельзя дать, оно постоянно ищется.

Повысить читаемость кода можно так же при помощи выделения сложных условий в переменные и функции, и комментирования.

Существует мнение, что хороший код не нуждается в комментариях. Это, конечно, не правда. Комментарий может не пояснять суть кода, но может пояснить намерения разработчика. Только в комментарии можно объяснить, почему некоторый код вынесен (или не вынесен) в отдельный метод, почему некоторый код дублируется и т. д. Комментарии полезны для того, чтобы выявить причины, намерения программиста, которые часто остаются за кадром.

Комментарии полезны ещё и для логического разделения кода. Ранее говорилось, что не всегда стоит дробить методы. Если метод разрастается и это нормально, комментарии могут помочь разделить зоны кода и объяснить их назначение.

*** 2.3. Не добавляйте новые сложности в имеющиеся классы
Этот пункт тоже совсем небольшой, поэтому разбивать его не будем.

Одна из основных причин разрастания единиц кода — добавление в них новой логики. Это разрастание может быть контролируемым или неконтролируемым. Держать развитие проекта под полным контролем очень трудно, ведь каждый раз нужно выяснять: эта новая логика — часть и развитие существующей или что-то новое? должна ли логика предметной области именно в этом пункте совпадать с логикой реализации?

В большинстве случаев разумно новые возможности выделять в отдельные единицы (классы, методы, функции). Это позволит увеличить связность кода и позволит лучше управлять зависимостями.

Кроме того, делить нужно и саму новую функциональность. Большие и сложные деловые процессы нужно разделять на меньшие, каждому подпроцессу ставить в соответствие свою собственную единицу.

#+begin_comment
Мысль. Проектирование ПО можно осуществлять на основе результатов анализа предметной области. Процессы, например, можно разлагать до таких элементарных частиц, от которых можно (не всегда напрямую) переходить к программным единицам.
#+end_comment

*** 2.4. Упражнения
№ 1, 3 и 4 не рассматриваются.

**** 2
Определённое время я держался мысли, что будущее за литературным (точнее, грамотным) программированием. Сейчас я отошёл от этой мысли. Код — не проза, код — это описание действий машины. Нельзя смешивать концепцию с реализацией.

Сейчас моё мнение таково, что в коде комментарии нужны для прояснения некоторых имён, причин, сигнатур. Но комментариев должно быть немного, комментировать всё подряд не стоит.

Куда важнее составить отдельное от кода описание общих концепций, фундаментального замысла.

** Глава 3. Обеспечение согласованности объектов
Одна из важнейших идей объектно-ориентированного программирования — это согласованность. Объект, раз он существует, существует по определённым правилам, в определённых границах. Нарушить эти правила невозможно, как невозможно нарушить согласованность существования любого, к примеру, вещественного объекта. Поддержанию целостности и посвящена эта глава.

*** 3.1. Обеспечьте постоянную согласованность
Обеспечение согласованности должно быть постоянным, простым. Оно должно быть настолько постоянным и простым, что его можно рассматривать, как свойство объекта.

**** 3.1.1. Сделайте класс ответственным за его собственную согласованность
Необходимость поддерживать согласованность вызывает вопрос «кто должен быть ответствен за это?».

В самых простых случаях объект сам должен отвечать за себя. Все операции, которые производятся над ним должны переводить его из одного согласованного состояния в другое. В этом случае клиентский код может свободно обращаться с объектом и не опасаться того, что он будет нарушен.
#+begin_comment
Вообще, поддержание согласованности силами объекта — это /норма/, один из принципов ООП (нормального ООП, как в Smalltalk или Self). Странно видеть этот базовый принцип в качестве рекомендации.
#+end_comment

Это значит, что всякий класс распадается на две крупные части:
- предметная логика,
- логика согласованности.

**** 3.1.2. Инкапсулируйте сложные проверки согласованности
Класс, как было сказано ранее, распадается на предметную логику и логику согласованности. Ясно, что логика согласованности может быть достаточно большой, она может зависеть от других классов и постепенно разрастаться. Как с этим бороться?

Объект должен обеспечивать свою согласованность. Но это не значит, что он как винегрет, должен включать в себя всё подряд. Если логика согласованности достаточно объёма, имеет множество зависимостей или представляет собой самостоятельную сущность, — тогда стоит отделить её.

Но отделение логики согласованности от объекта не должно быть абсолютным. Да, некоторые возможности становятся внешними, но мы всеми силами должны стараться возложить ответственность на объект.

**** 3.1.3. Пример: сущность Employee
Рассмотрим только содержание пункта, код приводиться не будет.

Сущность (а точнее, модель) в коде информационной системы должна быть не простым отображением таблицы в базе данных, а реальным объектом, который предоставляет набор операций. Доступ к БД предоставляют объекты-репозитории, модели же отражают поведение.

Например, класс Offering, описывающий предложение курса, должен предоставлять методы:
- addStudent,
- removeStudent,
- getAvailableSpots
- и т. д.

Эти методы предоставляют операции над моделью: добавление и удаление учащихся, получение числа свободных мест и т. д. Эти же методы проверяют согласованность объекта и если необходимо, вызывают ошибку (например, возвращают исключение, если свободных мест нет).

При этом нужно стараться скрыть внутреннюю реализацию объекта, сделать его таким, чтобы для клиента он был очевиден.

Если же требуется показать внутреннее состояние объекта (а такие случаи возможны), то разумно возвращать не сам объект, а его копию (или копию нужных свойств).

*** 3.2. Разработка эффективных механизмов валидации данных
Одна из важнейших составляющих сопровождаемого кода — повсеместная и грамотная валидация. Валидация данных служит продолжением идей предыдущего пункта.

**** 3.2.1. Сделайте предварительные условия явными
Первый важный аспект валидации — это предварительные условия. В отличие от согласованности объектов, которая представляет собой общий принцип, предусловия вполне конкретны и могут быть заложены в коде.

Возможность закодировать предусловия вызывает обязанность делать предусловия явными и понятными. Их нужно описывать для каждого параметра метода. Последнее требует от разработчика решить, как будут обрабатываться некорректные данные. Возможны два основных пути:
1) жёсткое ограничение некорректных операций: если данные неверны, то выполнить операцию невозможно;
2) сглаживание некорректности: получив некорректные данные, метод возвращает некоторое специальное значение (null или что-то ещё).

Однако, важно понимать ограничения обоих методов.

Жёсткая политика требует от клиентского кода полностью контролировать данные и обрабатывать все ошибки. Это в силу ряда причин может быть недопустимо.

С другой стороны, сглаживание делает методы слишком всеядными и устойчивыми. Система оказывается способной работать в очень широком диапазоне условий, а это может быть плохо. Излишняя устойчивость может устранять естественные, необходимые для клиентского кода и пользователей барьеры.

Лучший вариант, конечно, совмещать эти методы в зависимости от конкретных условий. Кроме того, возможно реализовать то, что могут многие функции Common Lisp: менять свою политику. Например, =read=, при достижении конца файла, может выдавать ошибку, а может возвращать определённое пользователем значение. Такой подход позволяет достичь баланса между клиентским и основным кодом: когда это необходимо, клиент может взять ответственность на себя, когда необходимо, переложить её.

В завершение пункта, Аниче говорит, что если возможно спроектировать метод, который не ломается, то это лучше сделать. Я не согласен. Мне кажется, основная цель проектирования метода — его предсказуемость. Если метод сломался, то мы можем с высокой точностью узнать, почему, если он работает без сбоев, мы можем объяснить это.

#+begin_comment
Вообще, всё сказанное ранее касается идей контрактного программирования. Жаль, что Аниче, даже вскользь о контрактах не говорит.
#+end_comment

**** 3.2.2. Создайте компоненты валидации
В пунктах 3.1. и 3.2.1. говорилось о логике внутренней согласованности объектов, пред- и постусловиях. От них нужно чётко отделять /правила валидации/.

Правила валидации относятся к согласованности данных с точки зрения /предметной области/. В отличие от них, согласованность объектов в целом и условия относятся к /реализации/ системы.

Однако отличие валидации от согласованности и условий состоит не только в этом. Согласованность должна быть атрибутом, признаком объекта, а условия — атрибутом метода. Правила валидации, напротив, представляют собой самостоятельные объекты, которые не стоит смешивать с сущностями предметной области.

К примеру, в корзине не может быть отрицательное число товаров. Это правило согласованности, которое присуще корзине всегда, вне зависимости от пожеланий и политики руководства компании. Однако можно произвольно наложить и так же произвольно снять ограничение на наибольшее количество товаров в корзине. Такое ограничение может распространяться на все товары вообще, или только на определённые (что имеет место в современности). Правила валидации, поэтому, крайне изменчивы и потому гибкой должна быть их реализация.

В силу сказанного, правила валидации самостоятельны не только в рамках предметной области, но и в реализации; они должны формировать отдельный компонент валидации.

**** 3.2.3. Осторожно используйте нулевые значения или избегайте их, если можете
Этот пункт у автора содержит, в основном, рассуждения о технической несостоятельности NULL-значений. Эти рассуждения интересны, но они имеют смысл только в связи с обсуждением уместности NULL в рамках предметной области.

Идею нулевых значений выдвинул в 1965 г. Тони Хоар. Он впоследствии очень жалел о содеянном. Действительно: очень часто NULL используется как универсальный заполнитель, что делает код сложнее. Но так же важно отметить, что чаще всего NULL не корректен с точки зрения логики.

В деловых процессах и рабочей среде не передаются пустые документы и нулевые значения. Там же, где можно использовать нули, выдаются ошибки и другие объекты.

Поэтому, прежде чем вводить в реализацию NULL необходимо проверить: будет ли это согласоваться с логикой предмета? В большинстве случаев окажется, что лучше передавать пустой список, ошибку или что-то другое. Полезно так же пользоваться Optional-значениями, которые дают достаточно гибкости и позволяют сделать проверки на отсутствие значения более стандартизированными и управляемыми.

**** 3.2.4. Пример: запись сотрудника на курс обучения
Пример, предлагаемый автором, интересен одним аспектом. Сервис валидации возвращает /список/ ошибок. Если во время записи нарушается сразу несколько правил, то в список будет записано несколько значений. Сам список представляет собой что-то близкое к optional.

Кроме того, авторы различает прикладные сервисы и сервисы предметной области. Сервисы предметной области включают в себя правила, отношения… — т. е. /логику предметной области/. Координацию этой логики выполняют прикладные сервисы: они не включают в себя логику, но управляют тем, как сервисы предметной области взаимодействуют друг с другом. Одним словом, так происходит разделение потока управления и бизнес-логики.

*** 3.3. Инкапсуляция проверок состояния
В этом разделе автор продолжает мысль об инкапсуляции логики согласованности и распространяет её на проверки состояния. Только класс (вообще говоря, объект) должен знать своё внутреннее состояние во всех деталях; клиенты должны получать его лишь через интерфейс, который класс предоставляет.

#+begin_comment
Вообще, это очередной основной принцип ООП.
#+end_comment

*** 3.4. Предусматривайте только геттеры и сеттеры, которые имеют значение
Этот раздел рационально конспектировать, как и предыдущий: наиболее кратко.

Мы должны предусматривать только семантические геттеры и сеттеры, это совершенно очевидно. Это очевидно, если вспомнить основные идеи ООП и передачу сообщений. Состояние объекта должно быть его личным делом, а интерфейс — способам повлиять на состояние и узнать о нём что-то. Интерфейс нужно определять не по состоянию, а по тому, как объект взаимодействует с другими объектами, какую роль он выполняет.

*** 3.5. Моделируйте агрегаты для обеспечения инвариантов в кластерах объектов
Этот раздел содержит весьма интересный материал, пересекающийся с тем, о чём мне приходилось часто думать.

Одна из основных проблем в обеспечении согласованности, состоит в том, что согласованность — свойство не только отдельных объектов, но и целой системы. Каждый объект по отдельности может быть согласован, а система — нет, и задача программиста заключается в том, чтобы эту согласованность поддерживать.

Но как поддерживать согласованность целой системы объектов? При помощи /корней агрегатов/, которые можно так же, без привязки к DDD называть средами.

Среда — это объект, который организует взаимодействие с между некоторым набором других объектов, а  качестве интерфейса предоставляет доступ для посылки сообщений этим объектам.

Среда позволяет, с одной стороны, разбить конкретную часть системы на множество объектов, каждый из которых отвечает за свою часть работы. С другой стороны, среда даёт унифицированный и понятный остальному приложению интерфейс, который скрывает детали взаимодействия объектов. Для всего остального мира, среда выглядит, как единая сущность, которая может выполнять целый ряд операций.

Нужно понимать, что среды предоставляют возможность скрыть реализацию и предоставить ясный интерфейс, а это значит, что они выполняют инкапсуляцию, но не на уровне объекта, а на уровне системы объектов.

**** 2.5.1. Не нарушайте правила корня агрегата
Среды (корни агрегатов) служат удобной абстракцией, но могут усложнять работу некоторого кода или снижать его производительность. В таких случаях кажется выгодным нарушить правило среды и залезть внутрь. Нужно ли это делать?

Нужно понимать, что если такая ситуация создаётся, то это приводит к нарушению самой идеи среды. Чтобы принять верное решение, нужно знать причины, по которым приходится делать такое нарушение.

Во-первых, разработчика может подталкивать неудобство или неуместность среды. В таком случае нарушение оправдано, а саму среду нужно будет убрать.

Во-вторых, разработчика может интересовать производительность. В таком случае нужно взвесить преимущества нарушения (повышение производительности) и их последствия (нарушение заложенных в архитектуру принципов, создание хрупких зависимостей).

** Глава 4. Управление зависимостями
*** 4.1. Разделение высоко- и низкоуровневого кода
В этом разделе автор вводит идеи, которые широко обсуждались в литературе о структурном программировании 70-80-х годов.

Проектировать систему нужно сверху вниз. Программист должен сначала определить верхний уровень (интерфейс и реализацию) и интерфейс нижнего уровня. Когда это сделано, он переходит к определению реализации нижнего уровня. Такой подход к проектированию и конструированию (нисходящая разработка) даёт возможность явно отделить высокоуровневый код от низкоуровневого.

Но как понять: где высокий, а где низкий уровень? Автор предлагает разделение по принципам «что» и «как». Высокоуровневый код не определяет реализации и не отвечает за неё, он лишь достигает цели (что). Низкоуровневый код, наоборот, не концентрируется на том, чего именно мы достигаем, его интересует то, как это сделать. Такое разделение очень близко к разделению императивного и декларативного программирования.

В этом вопросе так же вскрывается роль интерфейсов. Интерфейс, как программный объект, определяет только внешний вид, «что». Поэтому проектирование высокоуровневого кода заключается в проектировании интерфейсов.
#+begin_comment
Интересно, что стандартные интерфейсы в Java и C# не описывают состояние. Это совершенно Смолтоковский, динамический стиль.
#+end_comment

При этом, конечно, не нужно делать из этого принципа серебряной пули. Основой всего должна быть прагматичность. Иногда разделять код высокого и низкого уровней не стоит, иногда это и невозможно, ибо эти уровни не выделились в практике.

*** 4.2. Избегайте привязки к деталям или элементам, которые вам не нужны
Необходимо внимательно подходить к зависимостям: если какая-то библиотека или сервис могут меняться, то лучше работать с ними не напрямую, а через объект-прослойку.

При этом, конечно, не стоит оборачивать в прослойки всё подряд. Базовые фреймворки и библиотеки, лежащие в основе приложения оборачивать не нужно.

*** 4.3. Разбейте на части классы, которые зависят от множества других классов
Очень часто из-за ошибок проектирования один класс берёт на себя слишком много ответственности. Из-за этого он приобретает так же много зависимостей от окружения.

Наличие большого числа слабо связанных зависимостей — признак того, что класс спроектирован не правильно. Но даже если это соответствует предметной области, с технической точки зрения разумным может быть разбиение большого цельного класса на несколько меньших. Никто не сбережён от того, что требования поменяются, а всё большое распадётся на малое.

*** 4.4. Внедрение зависимостей
Наиболее важный из всех пунктов главы. С технической точки зрения создание композитных объектов, которые сами создают свои части, не слишком разумно.

В рамках логической модели что-то подобное может быть приемлемо:
#+begin_src js
  class Editor {
      costructor() {
          this.figureRepo = new FigureRepository();
          this.styleRepo = new StyleRepository();
      }
  }
#+end_src

Однако с технической точки зрения такие классы и такие конструкторы весьма неудобны. Если бы конструктор принимал заранее созданные части объекта, то стало бы возможным более гибкое тестирование (можно было бы передавать заглушки вместо реальных объектов).

Кроме того, стало бы возможным легко расширять функциональность приложения: вместо экземпляра нужного класса можно передать его подкласс с изменённой функциональностью.

** Глава 5. Разработка хороших абстракций
Если бы потребовалось дать определение программированию, то можно было бы сказать, что это есть «создание компьютерных абстракций». Создание абстракций вообще — это процесс познания. Создание компьютерных абстракций — это конкретное, практическое познание определённых сторон общественной жизни, т. е. программирование.

Несмотря на то, что абстракции стоят в самом центре программирования, дать удовлетворительное определение им автор не в силах. Он даёт несколько пунктов, каждый из которых, с одной стороны, не относится к абстракции, а с другой, повторяет все остальные.

Более содержательным выглядит цитата Дейкстры:
#+begin_quote
Быть абстрактным — нечто совершенно иное, чем быть неопределенным. Цель абстракции не в том, чтобы быть неопределенной, а в том, чтобы создать новый семантический уровень, на котором можно быть абсолютно точным
#+end_quote

Создание абстракций — это создание семантических уровней, при чём каждый новый уровень наследует определённые черты предыдущего, хотя отличается от него. Способность порождать новое без конфликта со старым — это основная ценность и основное предназначение абстракций.

*** 5.1. Проектирование абстракций и точек расширения
Теперь рассмотрим конкретнее проектирование абстракций.

**** 5.1.1. Определение потребности в абстракции
Когда необходимы абстракции? Автор считает, что существуют следующие основные случаи:
- известная вариативность: уже на этапе проектирования ясно, что существует большое число вариантов или комбинаций одной и той же операции;
- неизвестная вариативность: на этапе проектирования известно небольшое число вариантов и комбинаций, но можно ожидать, что это число быстро увеличится в будущем;
- сокрытие: необходимо скрыть некоторые части системы от других.

**** 5.1.3. Свойства хороших абстракций
Если абстракция действительно необходима, то какой она должна быть? Автор считает, что хорошая абстракция:
- отделяет цель от средств её достижения;
- имеет чёткий контракт;
- проста в использовании;
- устойчива и почти не меняется.

*** 5.2. Обобщайте важные бизнес-правила
Важная часть любой информационной системы — это бизнес-правила. Бизнес-правил всегда очень много и очень часто бывает, что два различных правила отличаются лишь своими параметрами. Это как раз случаи, когда необходимо создание абстракций.

Если структура бизнес-правил одинакова, а отличие состоит только в данных, то речь идёт о том, что существует обобщённое бизнес-правило, которое можно отобразить, как класс. Каждое конкретное бизнес-правило — это экземпляр класса.

В более сложных случаях потребуется использовать иные формы связи: наследование, агрегацию. Но вне зависимости от конкретной формы, подход к бизнес-правилам должен быть один, он должен быть рассчитан на изменчивость и расширяемость, так как жизнь меняется весьма быстро.

*** 5.3. Выбирайте простые абстракции
Абстракции дают множество возможностей, но они так же усложняют код. Как отыскать баланс между абстракциями и простыми решениями?

Автор предлагает три эмпирических правила:
1) введение абстракций должно вести к упрощению; если эмпирических оснований для абстракции нет, если не обозначилась её цель, то решение без абстракций будет лучше;
2) абстракции должны быть достаточны: если классы становятся больше, ветвления используются для передачи вариативности, а расширение системы становится сложнее, — во всех этих случаях простых решений недостаточно, а абстракций будет достаточно;
3) абстракции нужно проектировать сразу, как они становятся очевидны; если с первых дней ясно, что некоторая функциональность может изменяться и расширяться, то стоит вводить абстракции немедля.
