#+title: М. Аниче, Простое объектно-ориентированное проектирование
#+author: Centrix
#+date: <2025-09-07 Вс>
#+startup: overview
* Аннотация
* Конспект
** Глава 1. Управление сложностью
*** 1.1. Объектно-ориентированное проектирование и испытание временем
Все системы постоянно усложняются, это нормально. Самое важное в этом процессе — стремиться к /высокой сопровождаемости/ системы. Сохранение простоты, следование практикам чистого кода и т. п. — всё это не конечные цели, а только инструменты для достижения высокой сопровождаемости.

*** 1.2. Проектирование простых объектно-ориентированных систем
Что же такое сопровождаемость, а точнее, степень сопровождаемости?

Степень сопровождаемости — это величина усилий, которые нам необходимо приложить, чтобы:
1) изменить бизнес-правило,
2) добавить новые возможности,
3) исправить ошибку
4) и т. д.

Проект, у которого высокая степень сопровождаемости — это простой проект. Простота его состоит не в размере (проект может быть очень большим), а в том, насколько легко разобраться в отдельном компоненте, насколько легко внести изменение и проверить, что оно ничего не нарушает.

#+begin_comment
Понимание простоты, как сопровождаемости, будет использоваться далее во всей книге.
#+end_comment

Автор выделяет 6 принципов сохранения простоты (т. е. поддержания сопровождаемости):
1) простота кода,
2) согласованность объектов,
3) грамотность управления зависимостями,
4) высокое качество абстракций,
5) правильность работы с внешней инфраструктурой,
6) продуманная модульность.

Далее в главе даётся краткая характеристика каждого принципа. Детальному раскрытию принципов посвящены главы 2-7.

**** 1.2.1. Простой код
Первым, и самым явным, элементом простого проекта является простой код. Простота кода состоит, в основном, в его физической простоте — грамотном именовании, краткости, выразительности, 

**** 1.2.2. Согласованные объекты
Разработчик — это, в каком-то смысле, бог или творец. И опыт показывает, что мастерство бога — не всемогущество, а очень грамотное и тщательное самоограничение.

Ключ к созданию грамотных самоограничений — это согласованность объектов. Объекты не должны позволять делать с собой всё, что угодно. Они должны находиться лишь в определённом допустимом множестве состояний, выйти за которые несознательно нельзя. Если кто-то пытается ввести объект в состояние, в котором он не может существовать, этого кого-то нужно предупредить, а действие заблокировать.

#+begin_comment
Аниче приводит здесь пример с корзиной. Он говорит, что корзина должна управлять своим состоянием и не позволять, например, удалять из себя несуществующие товары. Это грамотная мысль.

Мне кажется, её можно развить: корзина не должна сама по себе управлять своим состоянием. Корзина — это хранилище, только хранилище и ничего более. А вот правила управления корзиной — это уже иная сущность. Управление корзиной стоит поручить отдельному классу — менеджеру корзины.

При таком подходе в проекте параллельно и непротиворечиво могут существовать несколько различных менеджеров корзины, которые реализуют различные правила.
#+end_comment

**** 1.2.3. Качественное управление зависимостями
В объекто-ориентированной системы классы будут неизбежно связываться друг с другом. Важно держать эти связи под контролем, в определённых условиями границах. Неграмотные зависимости могут порождать множество проблем: изменение одного класса ведёт к изменению другого, ошибка в одном месте порождает каскадный обвал во всей системе.

Поэтому классы (как и любые единицы проекта вообще) должны знать друг о друге как можно меньше.

**** 1.2.4. Хорошие абстракции
Абстракции необходимо проектировать с учётом дальнейшего расширения. Расширение должно быть стандартной, простой процедурой, выполнение которой никак не затрагивает существующий код.

**** 1.2.5. Правильная работа с внешними зависимостями и инфраструктурой
Инфраструктура — это всё, что находится за пределами нашей системы и требуется для её работы. Не смотря на то, что связь между системой и инфраструктурой очень высока, инфраструктура может со временем изменяться; на систему эти изменения влиять не должны.

Чтобы добиться гибкости в работе с инфраструктурой нужно отделять доменный слой от инфраструктурного слоя.

#+begin_comment
По-сути это требование напрямую исходит из качественного управления зависимостями. Единственное отличие между этими принципами состоит в том, что принцип разделения домена и архитектуры фокусируется на внешнем взаимодействии системы, на сохранении системы, как целого, в системе высшего порядка.
#+end_comment

**** 1.2.6. Продуманная модульность
Между принципом № 3 (управление зависимостями) и принципом №5 (разделение домена и инфраструктуры) стоит принцип № 6: принцип продуманной модульности.

Простую систему недостаточно разделить на классы, недостаточно отделить доменную логику от инфраструктурной. Необходимо так же грамотно разделять систему на внутренне связные целые — модули. Модули должны представлять собой чёрные ящики, которые знают друг о друге не дальше интерфейса.

Решение задачи приложения в таком случае сводится к правильной /координации/ модулей.

#+begin_comment
Акцент на слове «координация» важен потому, что модули должны быть совершенно независимы, их взаимодействие нужно координировать, организовать, как дирижёр помогает музыканту понять своё место в оркестре.
#+end_comment

*** 1.3. Простое проектирование как повседневная деятельность
Одна из важнейших идей автора — это повседневность, обыденность проектирования. Проектирование нужно рассматривать не как этап, который в развитии системы не повторяется, а как один из процессов жизнедеятельности системы. Пока система жива, она постоянно проектируется (а в большей степени — перепроектируется).

#+begin_comment
У этой мысли есть две неочевидные стороны, на которые автор не обращает внимания.

Во-первых, проектирование системы, если оно превращается в повседневную деятельность, должно быть достаточно простым, эффективным и быстрым. Оно должно быть так же просто и так же необходимо, как дыхание. Это означает, что проектирование нужно изучать, доводить его знание до такой степени, на которой некоторые действия будут выполняться автоматически. Это требует больших вложений, как когнитивных (разработчики должны быть хорошо обучены), так и организационных (должны существовать все условия для постоянного перепроектирования).

Во-вторых, идеальная (или простая) архитектура — это архитектура, которая стремится к идеалу (или простоте). То есть идеальность или простота архитектуры — это не статическая характеристика, не свойство, а закон развития архитектуры.
#+end_comment

Автор приводит следующие принципы простого, повседневного проектирования.
1. Уменьшение сложности системы (т. е. цель простого проектирования) сродни личной гигиене. Если человек для поддержания себя чистит зубы и моется, то систему нужно постоянно проектировать, нужно постоянно уменьшать её сложность.
2. Если сложность /сейчас/ неизбежна, то её нужно уменьшить /впоследствии/. Этот принцип вытекает из предыдущего: человек не всегда может почистить зубы, но он делает это, как только появляется такая возможность. Сложность нужно уменьшать тогда, когда путь к этому известен — обнаружен практикой или анализом предметной области.
3. Сокращение сложности — один из факторов экономической эффективности разработки. Системы, в которых сложность не сокращается, постепенно накапливают /технический долг/, т. е. массив нерешённых задач и проблем. Само существование этого массива и рост его приводит к дополнительным расходам — к процентам, которые причитаются к этому техническому /долгу/.
4. Качественный код порождает качественный код. Плохо спроектированная система будет вынуждать разработчиков принимать дальнейшие плохие решения. Это приводит к тому, что качество кода постоянно снижается, плохие решения порождают плохие решения. Качественный код служит обратным примером: он так же вынуждает разработчика принимать качественные решения, хотя сам он может этого и не замечать.
5. Сложность нужно обнаруживать, как можно раньше. (В оригинале этот пункт назван совершенно иначе, но я название даю по содержанию принципа.) В комментарии выше говорилось, что повседневное проектирование требует высокой квалификации разработчиков. Эта мысль раскрывается в данном принципе. Для обнаружения сложности на ранних стадиях реализации чего-либо (всей системы, отдельной функции) разработчики должны обладать большим опытом и знаниями.
6. Удержание сложности — долг разработчика. Прямая обязанность разработчика состоит в том, чтобы поддерживать ценность системы для организации. Система, неспособная удовлетворить нужды организации, бесполезна. Но в нужды организации входит не только автоматизация некоторых функций, но и разумная экономия. Поэтому разработчик должен поддерживать систему такой, чтобы обслуживание её не требовало сверхъестественных затрат.
7. Необходимо достигать «достаточно хороших» решений. Ранее говорилось, что проектирование — это постоянный, итеративный процесс. Опыт показывает, что найти лучшее решение с первого раза нельзя. Поэтому стоит принимать «достаточно хорошие» решения, т. е. такие решения, которые решают поставленную задачу и делают это «чуть выше среднего».

#+begin_comment
По этим принципам нужно заметить следующее.

Принципы 1 и 3 в самом общем смысле применимы не только к сложности.

Одна из трудностей, с которой сталкиваются разработчики больших систем, — это устаревание технологий, выходят новые версии языков программирования, библиотек, а систему нельзя переписать сразу. Иногда объём систем столь велик, что переписывание вообще экономически нецелесообразно.

Однако постепенное переписывание системы, переписывание, как повседневная задача, уже вполне возможно. Но такой подход требует грамотного проектирования системы, среды исполнения; кроме того, необходимо продуманное управление, которого обычно нет (а ведь именно его отсутствие и приводит к появлению огромных и не переписываемых систем).

Принцип 4, как многие общие принципы программирования (например, DRY и KISS) достаточно абстрактен. Ясное дело, что невозможно в /общем/ принципе предусмотреть все возможные /частные/ случаи. Но это не значит, что общий принцип вообще должен абстрагироваться от чего бы то ни было. Необходимо определить критерии качественного решения.
#+end_comment

*** 1.4. Краткое знакомство с архитектурой системы
#+begin_comment
Эту часть конспекта стоит расценивать не как конспект, а как интерпретацию. Реально законспектировать параграф 1.4 трудно, так как автор выражается весьма неконкретно, в его изложении почти нет системы. Я попытался эту систему внести.
#+end_comment

Далее в книге примером будет служить информационная система с веб-интерфейсом. В этом параграфе автор делает краткий экскурс в устройство ИС.

Архитектуру системы-примера можно рассмотреть с двух точек зрения:
1) точка зрения веб-технологий,
2) точка зрения логического строения системы.

С точки зрения веб-технологий система-пример представляет собой совокупность фронтенда, бэкенда и БД. Из этих компонентов автора больше всего интересует бэкенд.

С точки зрения логического строения, система-пример распадается на представление, контроллер и модель (MVC). Представлением служит фронтенд, контроллер и модель — части бэкенда. Автора больше всего интересует модель, ведь именно она сосредотачивает в себе все проблемы.

#+caption: Связь т. з. веб-технологий и логического строения
#+org_attr: :scale 1
[[file:img/01-1.4-arch.drawio.png]]

В состав модели входят следующие типичные классы:
- сущности — это /классы/ (т. е. речь о классах, а не сущностях логической модели БД), которые представляют классы объектов предметной области;
- сервисы — это классы, которые описывают сложные правила предметной области, взаимодействие сущностей;
- репозитории — это классы, ответственные за хранение данных (они взаимодействуют с БД);
- адаптеры — это классы, ответственные за взаимодействие с инфраструктурой.
#+begin_comment
Такой состав модели отражает её истинную, активную роль. Модель — это не просто код доступа к СУБД, это программное отражение объекта предметной области. Хранение, доставка и получение данных тоже входят в обязанности модели (для этого там есть репозитории и адаптеры), но сердце и суть модели в предметной области, т. е. в сущностях и сервисах.
#+end_comment

Во взаимодействии модели и контроллера большую роль играют:
- объекты передачи данных (ОПД, DTO) — это классы, которые отвечают за хранение и передачу данных /внутри бэкенда/ (это отличает ОПД от репозиториев, которые работают уже с БД);
- утилитарные классы.

#+caption: Соотношение классов и компонентов MVC
#+org_attr: :scale 1
[[file:img/01-1.4-class.drawio.png]]

Приведённая ранее архитектура достаточно общая и универсальная, не стоит рассматривать её как архитектуру конкретную, вроде предметно-ориентированной архитектуры (DDD) или архитектуры микросервисов.

*** 1.5. Пример проекта: PeopleGrow!
Теперь автор конкретно рассказывает о примере ИС, которая используется в книге. Эта ИС — приложение для отслеживания роста квалификации сотрудников PeopleGrow!. Ничего интересного в описании этой системы нет.

*** 1.6. Упражнения
**** 1
Понимание термина «простое объектно-ориентированное проектирование» зависит от понимания слова «простое».

Простоту можно отождествить со скоростью, т. е. с тем, что времени и сил на проектирование отводится немного. Но такое понимание обманчиво, ибо исходная простота и скорость оборачивается сложностью и длительностью впоследствии.

Значит, простоту нужно понимать глубже. Простота — это согласованность и ясность логики, точность отображения предметной области. Этих трёх характеристик (а особенно точности) добиться быстро нельзя, они — предмет серьёзного проектирования. Но серьёзное проектирование будет действительно серьёзным тогда, когда оно будет постоянным, непрерывным.

Непрерывность проектирования приводит к тому, что оно становится обыденной задачей, начинает постепенно сливаться с разработкой, не лишаясь при этом своих особенностей. Так проектирование становится /простым/, т. е. вливается в жизнь. Простота проектирования подобна простоте дыхания. Дыхание — сложный процесс, но он происходит незаметно, хотя очень точно и верно. В этом состоит его простота. В этом простота и непрерывного, постоянного проектирования и перепроектирования.

**** 3
Сохранить простоту проекта возможно, но нужно понимать, что в результате непрерывного проектирования система перерождается, эволюционирует. Поэтому само понятие простоты так же изменяется. Простота — это не состояние и не свойство, это стремление.

Среди проблем, которые связаны с сохранением простоты, можно выделить:
- изменение связанных с системой компонентов: изменение API СУБД или внешних сервисов;
- рассогласование объектов: развитие системы — это прогресс в познании предметной области, чем точнее система отображает объекты реального мира, тем сложнее они оказываются, тем больше различий между ними; то, что было единым и согласованным становится множественным и несовместимым; возникает потребность в перепроектировании;
- разрастание кода и модульной системы: по мере усложнения системы в ней появляется всё больше модулей, методы становятся всё длиннее, первоначальная выразительность сменяется многословием; если не бороться с этими явлениями, то ситуация будет со временем только ухудшаться.
