#+title: М. Аниче, Простое объектно-ориентированное проектирование
#+author: Centrix
#+startup: content
* Аннотация
* Конспект
** Предупреждение
Нижеследующий конспект — не конспект в полном смысле этого слова. Очень часто авторская мысль здесь дополняется мыслями читателя.

** Глава 1. Управление сложностью
*** 1.1. Объектно-ориентированное проектирование и испытание временем
Все системы постоянно усложняются, это нормально. Самое важное в этом процессе — стремиться к /высокой сопровождаемости/ системы. Сохранение простоты, следование практикам чистого кода и т. п. — всё это не конечные цели, а только инструменты для достижения высокой сопровождаемости.

*** 1.2. Проектирование простых объектно-ориентированных систем
Что же такое сопровождаемость, а точнее, степень сопровождаемости?

Степень сопровождаемости — это величина усилий, которые нам необходимо приложить, чтобы:
1) изменить бизнес-правило,
2) добавить новые возможности,
3) исправить ошибку
4) и т. д.

Проект, у которого высокая степень сопровождаемости — это простой проект. Простота его состоит не в размере (проект может быть очень большим), а в том, насколько легко разобраться в отдельном компоненте, насколько легко внести изменение и проверить, что оно ничего не нарушает.

#+begin_comment
Понимание простоты, как сопровождаемости, будет использоваться далее во всей книге.
#+end_comment

Автор выделяет 6 принципов сохранения простоты (т. е. поддержания сопровождаемости):
1) простота кода,
2) согласованность объектов,
3) грамотность управления зависимостями,
4) высокое качество абстракций,
5) правильность работы с внешней инфраструктурой,
6) продуманная модульность.

Далее в главе даётся краткая характеристика каждого принципа. Детальному раскрытию принципов посвящены главы 2-7.

**** 1.2.1. Простой код
Первым, и самым явным, элементом простого проекта является простой код. Простота кода состоит, в основном, в его физической простоте — грамотном именовании, краткости, выразительности, 

**** 1.2.2. Согласованные объекты
Разработчик — это, в каком-то смысле, бог или творец. И опыт показывает, что мастерство бога — не всемогущество, а очень грамотное и тщательное самоограничение.

Ключ к созданию грамотных самоограничений — это согласованность объектов. Объекты не должны позволять делать с собой всё, что угодно. Они должны находиться лишь в определённом допустимом множестве состояний, выйти за которые несознательно нельзя. Если кто-то пытается ввести объект в состояние, в котором он не может существовать, этого кого-то нужно предупредить, а действие заблокировать.

#+begin_comment
Аниче приводит здесь пример с корзиной. Он говорит, что корзина должна управлять своим состоянием и не позволять, например, удалять из себя несуществующие товары. Это грамотная мысль.

Мне кажется, её можно развить: корзина не должна сама по себе управлять своим состоянием. Корзина — это хранилище, только хранилище и ничего более. А вот правила управления корзиной — это уже иная сущность. Управление корзиной стоит поручить отдельному классу — менеджеру корзины.

При таком подходе в проекте параллельно и непротиворечиво могут существовать несколько различных менеджеров корзины, которые реализуют различные правила.
#+end_comment

**** 1.2.3. Качественное управление зависимостями
В объекто-ориентированной системы классы будут неизбежно связываться друг с другом. Важно держать эти связи под контролем, в определённых условиями границах. Неграмотные зависимости могут порождать множество проблем: изменение одного класса ведёт к изменению другого, ошибка в одном месте порождает каскадный обвал во всей системе.

Поэтому классы (как и любые единицы проекта вообще) должны знать друг о друге как можно меньше.

**** 1.2.4. Хорошие абстракции
Абстракции необходимо проектировать с учётом дальнейшего расширения. Расширение должно быть стандартной, простой процедурой, выполнение которой никак не затрагивает существующий код.

**** 1.2.5. Правильная работа с внешними зависимостями и инфраструктурой
Инфраструктура — это всё, что находится за пределами нашей системы и требуется для её работы. Не смотря на то, что связь между системой и инфраструктурой очень высока, инфраструктура может со временем изменяться; на систему эти изменения влиять не должны.

Чтобы добиться гибкости в работе с инфраструктурой нужно отделять доменный слой от инфраструктурного слоя.

#+begin_comment
По-сути это требование напрямую исходит из качественного управления зависимостями. Единственное отличие между этими принципами состоит в том, что принцип разделения домена и архитектуры фокусируется на внешнем взаимодействии системы, на сохранении системы, как целого, в системе высшего порядка.
#+end_comment

**** 1.2.6. Продуманная модульность
Между принципом № 3 (управление зависимостями) и принципом №5 (разделение домена и инфраструктуры) стоит принцип № 6: принцип продуманной модульности.

Простую систему недостаточно разделить на классы, недостаточно отделить доменную логику от инфраструктурной. Необходимо так же грамотно разделять систему на внутренне связные целые — модули. Модули должны представлять собой чёрные ящики, которые знают друг о друге не дальше интерфейса.

Решение задачи приложения в таком случае сводится к правильной /координации/ модулей.

#+begin_comment
Акцент на слове «координация» важен потому, что модули должны быть совершенно независимы, их взаимодействие нужно координировать, организовать, как дирижёр помогает музыканту понять своё место в оркестре.
#+end_comment

*** 1.3. Простое проектирование как повседневная деятельность
Одна из важнейших идей автора — это повседневность, обыденность проектирования. Проектирование нужно рассматривать не как этап, который в развитии системы не повторяется, а как один из процессов жизнедеятельности системы. Пока система жива, она постоянно проектируется (а в большей степени — перепроектируется).

#+begin_comment
У этой мысли есть две неочевидные стороны, на которые автор не обращает внимания.

Во-первых, проектирование системы, если оно превращается в повседневную деятельность, должно быть достаточно простым, эффективным и быстрым. Оно должно быть так же просто и так же необходимо, как дыхание. Это означает, что проектирование нужно изучать, доводить его знание до такой степени, на которой некоторые действия будут выполняться автоматически. Это требует больших вложений, как когнитивных (разработчики должны быть хорошо обучены), так и организационных (должны существовать все условия для постоянного перепроектирования).

Во-вторых, идеальная (или простая) архитектура — это архитектура, которая стремится к идеалу (или простоте). То есть идеальность или простота архитектуры — это не статическая характеристика, не свойство, а закон развития архитектуры.
#+end_comment

Автор приводит следующие принципы простого, повседневного проектирования.
1. Уменьшение сложности системы (т. е. цель простого проектирования) сродни личной гигиене. Если человек для поддержания себя чистит зубы и моется, то систему нужно постоянно проектировать, нужно постоянно уменьшать её сложность.
2. Если сложность /сейчас/ неизбежна, то её нужно уменьшить /впоследствии/. Этот принцип вытекает из предыдущего: человек не всегда может почистить зубы, но он делает это, как только появляется такая возможность. Сложность нужно уменьшать тогда, когда путь к этому известен — обнаружен практикой или анализом предметной области.
3. Сокращение сложности — один из факторов экономической эффективности разработки. Системы, в которых сложность не сокращается, постепенно накапливают /технический долг/, т. е. массив нерешённых задач и проблем. Само существование этого массива и рост его приводит к дополнительным расходам — к процентам, которые причитаются к этому техническому /долгу/.
4. Качественный код порождает качественный код. Плохо спроектированная система будет вынуждать разработчиков принимать дальнейшие плохие решения. Это приводит к тому, что качество кода постоянно снижается, плохие решения порождают плохие решения. Качественный код служит обратным примером: он так же вынуждает разработчика принимать качественные решения, хотя сам он может этого и не замечать.
5. Сложность нужно обнаруживать, как можно раньше. (В оригинале этот пункт назван совершенно иначе, но я название даю по содержанию принципа.) В комментарии выше говорилось, что повседневное проектирование требует высокой квалификации разработчиков. Эта мысль раскрывается в данном принципе. Для обнаружения сложности на ранних стадиях реализации чего-либо (всей системы, отдельной функции) разработчики должны обладать большим опытом и знаниями.
6. Удержание сложности — долг разработчика. Прямая обязанность разработчика состоит в том, чтобы поддерживать ценность системы для организации. Система, неспособная удовлетворить нужды организации, бесполезна. Но в нужды организации входит не только автоматизация некоторых функций, но и разумная экономия. Поэтому разработчик должен поддерживать систему такой, чтобы обслуживание её не требовало сверхъестественных затрат.
7. Необходимо достигать «достаточно хороших» решений. Ранее говорилось, что проектирование — это постоянный, итеративный процесс. Опыт показывает, что найти лучшее решение с первого раза нельзя. Поэтому стоит принимать «достаточно хорошие» решения, т. е. такие решения, которые решают поставленную задачу и делают это «чуть выше среднего».

#+begin_comment
По этим принципам нужно заметить следующее.

Принципы 1 и 3 в самом общем смысле применимы не только к сложности.

Одна из трудностей, с которой сталкиваются разработчики больших систем, — это устаревание технологий, выходят новые версии языков программирования, библиотек, а систему нельзя переписать сразу. Иногда объём систем столь велик, что переписывание вообще экономически нецелесообразно.

Однако постепенное переписывание системы, переписывание, как повседневная задача, уже вполне возможно. Но такой подход требует грамотного проектирования системы, среды исполнения; кроме того, необходимо продуманное управление, которого обычно нет (а ведь именно его отсутствие и приводит к появлению огромных и не переписываемых систем).

Принцип 4, как многие общие принципы программирования (например, DRY и KISS) достаточно абстрактен. Ясное дело, что невозможно в /общем/ принципе предусмотреть все возможные /частные/ случаи. Но это не значит, что общий принцип вообще должен абстрагироваться от чего бы то ни было. Необходимо определить критерии качественного решения.
#+end_comment

*** 1.4. Краткое знакомство с архитектурой системы
#+begin_comment
Эту часть конспекта стоит расценивать не как конспект, а как интерпретацию. Реально законспектировать параграф 1.4 трудно, так как автор выражается весьма неконкретно, в его изложении почти нет системы. Я попытался эту систему внести.
#+end_comment

Далее в книге примером будет служить информационная система с веб-интерфейсом. В этом параграфе автор делает краткий экскурс в устройство ИС.

Архитектуру системы-примера можно рассмотреть с двух точек зрения:
1) точка зрения веб-технологий,
2) точка зрения логического строения системы.

С точки зрения веб-технологий система-пример представляет собой совокупность фронтенда, бэкенда и БД. Из этих компонентов автора больше всего интересует бэкенд.

С точки зрения логического строения, система-пример распадается на представление, контроллер и модель (MVC). Представлением служит фронтенд, контроллер и модель — части бэкенда. Автора больше всего интересует модель, ведь именно она сосредотачивает в себе все проблемы.

#+caption: Связь т. з. веб-технологий и логического строения
#+org_attr: :scale 1
[[file:img/01-1.4-arch.drawio.png]]

В состав модели входят следующие типичные классы:
- сущности — это /классы/ (т. е. речь о классах, а не сущностях логической модели БД), которые представляют классы объектов предметной области;
- сервисы — это классы, которые описывают сложные правила предметной области, взаимодействие сущностей;
- репозитории — это классы, ответственные за хранение данных (они взаимодействуют с БД);
- адаптеры — это классы, ответственные за взаимодействие с инфраструктурой.
#+begin_comment
Такой состав модели отражает её истинную, активную роль. Модель — это не просто код доступа к СУБД, это программное отражение объекта предметной области. Хранение, доставка и получение данных тоже входят в обязанности модели (для этого там есть репозитории и адаптеры), но сердце и суть модели в предметной области, т. е. в сущностях и сервисах.
#+end_comment

Во взаимодействии модели и контроллера большую роль играют:
- объекты передачи данных (ОПД, DTO) — это классы, которые отвечают за хранение и передачу данных /внутри бэкенда/ (это отличает ОПД от репозиториев, которые работают уже с БД);
- утилитарные классы.

#+caption: Соотношение классов и компонентов MVC
#+org_attr: :scale 1
[[file:img/01-1.4-class.drawio.png]]

Приведённая ранее архитектура достаточно общая и универсальная, не стоит рассматривать её как архитектуру конкретную, вроде предметно-ориентированной архитектуры (DDD) или архитектуры микросервисов.

*** 1.5. Пример проекта: PeopleGrow!
Теперь автор конкретно рассказывает о примере ИС, которая используется в книге. Эта ИС — приложение для отслеживания роста квалификации сотрудников PeopleGrow!. Ничего интересного в описании этой системы нет.

*** 1.6. Упражнения
№ 2 не рассматривается.

**** 1
Понимание термина «простое объектно-ориентированное проектирование» зависит от понимания слова «простое».

Простоту можно отождествить со скоростью, т. е. с тем, что времени и сил на проектирование отводится немного. Но такое понимание обманчиво, ибо исходная простота и скорость оборачивается сложностью и длительностью впоследствии.

Значит, простоту нужно понимать глубже. Простота — это согласованность и ясность логики, точность отображения предметной области. Этих трёх характеристик (а особенно точности) добиться быстро нельзя, они — предмет серьёзного проектирования. Но серьёзное проектирование будет действительно серьёзным тогда, когда оно будет постоянным, непрерывным.

Непрерывность проектирования приводит к тому, что оно становится обыденной задачей, начинает постепенно сливаться с разработкой, не лишаясь при этом своих особенностей. Так проектирование становится /простым/, т. е. вливается в жизнь. Простота проектирования подобна простоте дыхания. Дыхание — сложный процесс, но он происходит незаметно, хотя очень точно и верно. В этом состоит его простота. В этом простота и непрерывного, постоянного проектирования и перепроектирования.

**** 3
Сохранить простоту проекта возможно, но нужно понимать, что в результате непрерывного проектирования система перерождается, эволюционирует. Поэтому само понятие простоты так же изменяется. Простота — это не состояние и не свойство, это стремление.

Среди проблем, которые связаны с сохранением простоты, можно выделить:
- изменение связанных с системой компонентов: изменение API СУБД или внешних сервисов;
- рассогласование объектов: развитие системы — это прогресс в познании предметной области, чем точнее система отображает объекты реального мира, тем сложнее они оказываются, тем больше различий между ними; то, что было единым и согласованным становится множественным и несовместимым; возникает потребность в перепроектировании;
- разрастание кода и модульной системы: по мере усложнения системы в ней появляется всё больше модулей, методы становятся всё длиннее, первоначальная выразительность сменяется многословием; если не бороться с этими явлениями, то ситуация будет со временем только ухудшаться.

** Глава 2. Сокращение кода
Автор говорит о вреде /длинных/ единиц кода (методов, классов). При этом он невольно отождествляет /длину/ и /сложность/. Объединение этих понятий уместно в большинстве случаев, т. е. в случаях очевидных. В случаях неочевидных, редких такое отождествление приносит огромный вред.

В целом автор, конечно, прав. Однако упущение этой детали делает изложение поверхностным.

*** 2.1. Уменьшите единицы кода
Необходимость уменьшать код связана не со стремлением к лаконичности или красоте. Конечно, они играют имеет роль, но программирование является программированием потому, что решающую роль в нём играет практичность.

Каковы практические последствия удлинения единиц кода?

Во-первых, произвольное разрастание единиц кода может быть симптомом искажения логики предметной области. Чаще всего большие методы и классы смешивают в одной сущности сразу несколько самостоятельных объектов. Развитие таких единиц кода может только ухудшить ситуацию и сделать систему несовместимой с предметной областью.

Во-вторых, удлинение единиц кода снижает его тестируемость. Если причиной большой длины служит смешение различного, то полно и достоверно протестировать код становится затруднительным.

В-третьих, удлинение кода снижает его расширяемость. Самостоятельные единицы кода на то и самостоятельны, что их можно заменить другими при помощи точно определённой и ясной процедуры.

#+begin_comment
Автор, кроме прочего, указывает, что длинные методы и классы больше подвержены изменениям и ошибкам. Неизвестной остаётся, однако, причина этого. Она может быть в том, что такие единицы сложнее поддерживать. А может быть в том, что они просто /больше/. В чём истина непонятно.
#+end_comment

Все эти следствия могут значительно усложнять разработку, поэтому необходимо уменьшать единицы кода. Как именно это делать? Ответ на этот вопрос дан в следующих подразделах.

**** 2.1.1. Разбивайте сложные методы на закрытые
Длинные методы необходимо разбивать на более мелкие и, как правило, закрытые. Целью разбиения методов должно быть достижение /связности/.

Связность — это целостность, которая изменяется по собственному закону и остаётся неизменной в различных условиях применения.
#+begin_comment
Это определение отсутствует в книге. Автор определяет связность просто, как наличие единой ответственности. Это определение весьма скудно и мало даёт читателю, поэтому я дал своё.
#+end_comment

Это определение значит, что:
- связный метод — это целостный метод, все его части крепко связаны, а их разделение будет только вредить;
- связный метод изменяется, развивается по своим собственным, независимым законам;
- связный метод может действовать в несколько разных условиях, оставаясь при этом неизменным.

Второй пункт, пункт о законах изменения представляется наиболее важным.

Автор приводит следующие условия того, что метод стоит выделить из другого:
1) методу легко подобрать имя, это имя будет чётко и ясно определять суть метода;
2) метод выполняет небольшое, целостное действие, которое может использоваться в открытом методе;
3) метод не слишком сильно переплетён с параметрами открытого метода и состоянием объекта;
4) метод можно сделать статическим (важно, что его /можно/ сделать статическим, это не означает, что его /нужно/ сделать таким).

Эти условия помогают понять, нужно ли вынести часть одного метода в другой метод (обычно, закрытый). Но возможен случай, когда из метода выделяется не новый метод, а класс. Этот случай рассмотрен в следующем разделе.

**** 2.1.2. Переместите сложную часть кода в другой класс
В ряде случаев оказывается полезным выделить часть длинного метода в отдельный класс. Автор приводит следующие условия этого:
1) метод не зависит от данного класса;
2) метод зависит от других классов;
3) метод принадлежит самостоятельному объекту предметной области;
4) метод необходимо тестировать, как самостоятельную единицу.

#+begin_comment
Важно понимать, что пункты 1-2 имеют смысл только для объектных систем с передачей сообщений. В таких системах метод принадлежит классам и их экземплярам. Объектные системы в Java, C#, Python реализуют именно такой механизм.

Но кроме систем с передачей сообщений, существуют системы с мультиметодами. В таких системах метод представляет собой самостоятельную сущность, которая /связывается/ с классом, но не /принадлежит/ ему. Мультиметоды встречаются в CL, Elixir, Dylan.
#+end_comment

Однако есть случаи, когда разделение кода может быть вредным. Рассмотрим их.

**** 2.1.3. Когда не стоит разделять код на небольшие единицы
Не стоит разделять код на небольшие единицы тогда, когда эти единицы /целостны/, и как целое развиваются по своим законам. Более конкретно это означает, что:
- разделение единиц затруднительно — они слишком сильно переплетаются друг с другом;
- разделённые единицы невозможно будет заменить;
- разделяемые единицы невозможно протестировать независимо.

Кроме того, не стоит забывать о практичности. Код, разделённый слишком сильно, становится слишком трудным для поддержки, возникает проблема правильного связывания элементов.

Ситуацию, когда целостный класс разделён на множество мелких, Джон Оустерхаут называл /классянкой/.

Все перечисленные ранее правила стоит, очевидно, применять до рефакторинга. Хорошо представлять, как именно преобразуется код, возникнут ли какие-нибудь проблемы. В этом состоит содержание раздела 2.1.4., который не вынесен в этом конспекте в отдельный пункт.

Следующий раздел — 2.1.5. содержит пример разделения методов. Интереснейшая его особенность в том, что автор не пытается довести код до идеала. Он делает его лучше и останавливается тогда, когда необходимости в дальнейшем разделении практика не обозначает. В этом сказывается суть /простого ОО-проектирования/ — стремиться к идеалу не статически, а динамически, объединить перепроектирование и кодинг.

*** 2.2. Сделайте код читаемым и документируйте его
В целом этот раздел можно изложить очень кратко. Деление его на подразделы кажется излишним.

Код должен быть читаемым. Это не значит, что он должен читаться, как рассказ, подобное утверждение слишком сильно, оно не учитывает, что код должен быть /практичным/, а не /идеальным/. Тем не менее, код должен быть выразительным и точным. Одна из основ этого — ясность имён. Самый важный принцип именования таков: имена нужно постоянно искать. Если опыт показывает новое, ещё более точное имя, то его следует использовать. Если же ничего такого нет, имя можно оставить. Одним словом, хорошее имя нельзя дать, оно постоянно ищется.

Повысить читаемость кода можно так же при помощи выделения сложных условий в переменные и функции, и комментирования.

Существует мнение, что хороший код не нуждается в комментариях. Это, конечно, не правда. Комментарий может не пояснять суть кода, но может пояснить намерения разработчика. Только в комментарии можно объяснить, почему некоторый код вынесен (или не вынесен) в отдельный метод, почему некоторый код дублируется и т. д. Комментарии полезны для того, чтобы выявить причины, намерения программиста, которые часто остаются за кадром.

Комментарии полезны ещё и для логического разделения кода. Ранее говорилось, что не всегда стоит дробить методы. Если метод разрастается и это нормально, комментарии могут помочь разделить зоны кода и объяснить их назначение.

*** 2.3. Не добавляйте новые сложности в имеющиеся классы
Этот пункт тоже совсем небольшой, поэтому разбивать его не будем.

Одна из основных причин разрастания единиц кода — добавление в них новой логики. Это разрастание может быть контролируемым или неконтролируемым. Держать развитие проекта под полным контролем очень трудно, ведь каждый раз нужно выяснять: эта новая логика — часть и развитие существующей или что-то новое? должна ли логика предметной области именно в этом пункте совпадать с логикой реализации?

В большинстве случаев разумно новые возможности выделять в отдельные единицы (классы, методы, функции). Это позволит увеличить связность кода и позволит лучше управлять зависимостями.

Кроме того, делить нужно и саму новую функциональность. Большие и сложные деловые процессы нужно разделять на меньшие, каждому подпроцессу ставить в соответствие свою собственную единицу.

#+begin_comment
Мысль. Проектирование ПО можно осуществлять на основе результатов анализа предметной области. Процессы, например, можно разлагать до таких элементарных частиц, от которых можно (не всегда напрямую) переходить к программным единицам.
#+end_comment

*** 2.4. Упражнения
№ 1, 3 и 4 не рассматриваются.

**** 2
Определённое время я держался мысли, что будущее за литературным (точнее, грамотным) программированием. Сейчас я отошёл от этой мысли. Код — не проза, код — это описание действий машины. Нельзя смешивать концепцию с реализацией.

Сейчас моё мнение таково, что в коде комментарии нужны для прояснения некоторых имён, причин, сигнатур. Но комментариев должно быть немного, комментировать всё подряд не стоит.

Куда важнее составить отдельное от кода описание общих концепций, фундаментального замысла.
